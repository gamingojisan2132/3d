<!DOCTYPE html>
<html>
<head>
    <title>Three.js Voxel Scene with Enemies</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background-color: #3399FF; }
        canvas { display: block; }
        #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; }
        #instructions { width: 50%; cursor: pointer; background-color: white; padding: 20px; text-align: center; border-radius: 5px; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:24px; font-weight: bold;">クリックして開始</p>
            <p>WASD: 移動<br/>スペース: ジャンプ<br/>マウス: 視点移動<br/>クリック: ボールを発射<br/>ESC: 操作解除</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as CANNON from 'cannon-es';
        // import CannonDebugger from 'cannon-es-debugger'; // Optional

        // --- Global Variables ---
        let scene, camera, renderer, controls, world;
        let groundBody, playerBody;
        const meshes = [];
        const bodies = [];

        // Physics Materials
        let groundMaterial, playerMaterial, ballPhysicsMaterial, enemyMaterial;

        const timeStep = 1 / 60;
        const playerHeight = 1.7;
        const playerRadius = 0.4;
        const playerMass = 65;
        const moveSpeed = 18;
        const jumpVelocity = 21;

        // Movement state
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;

        // Ball shooting variables
        const balls = [];
        const ballShape = new CANNON.Sphere(0.15);
        const ballGeometry = new THREE.SphereGeometry(ballShape.radius, 16, 16);
        const ballMeshMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333, metalness: 0.3, roughness: 0.6 });

        // Enemy variables
        const enemies = [];
        const enemySpeed = 5;
        const enemyCollisionGroup = 2;
        const playerCollisionGroup = 1;
        const ballCollisionGroup = 4;

        // --- Initialization ---
        function init() {
            console.log("Initializing...");
            try {
                initThree();
                initCannon();
                initPointerLock(); // ここで controls が初期化されるはず
                createEnvironment();
                createPlayer();
                createLights();
                console.log("Initialization complete. Starting animation loop.");
                animate(); // animate開始
            } catch (error) {
                console.error("Initialization failed:", error);
                displayError("初期化中にエラーが発生しました。コンソールを確認してください。");
            }
        }

        // --- Three.js Setup --- (unchanged)
        function initThree() { console.log("Initializing Three.js..."); scene = new THREE.Scene(); scene.background = new THREE.Color(0x3399FF); scene.fog = new THREE.Fog(0x3399FF, 30, 120); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.y = playerHeight; renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); window.addEventListener('resize', onWindowResize); console.log("Three.js initialized."); }

        // --- Cannon.js (Physics) Setup --- (unchanged)
        function initCannon() { console.log("Initializing Cannon.js..."); world = new CANNON.World(); world.gravity.set(0, -25, 0); world.broadphase = new CANNON.SAPBroadphase(world); world.allowSleep = true; groundMaterial = new CANNON.Material("ground"); playerMaterial = new CANNON.Material("player"); ballPhysicsMaterial = new CANNON.Material("ball"); enemyMaterial = new CANNON.Material("enemy"); const playerGround = new CANNON.ContactMaterial(groundMaterial, playerMaterial, { friction: 0.3, restitution: 0.0 }); const ballGround = new CANNON.ContactMaterial(groundMaterial, ballPhysicsMaterial, { friction: 0.4, restitution: 0.6 }); const ballPlayer = new CANNON.ContactMaterial(playerMaterial, ballPhysicsMaterial, { friction: 0.1, restitution: 0.3 }); const ballBall = new CANNON.ContactMaterial(ballPhysicsMaterial, ballPhysicsMaterial, { friction: 0.5, restitution: 0.9 }); const enemyGround = new CANNON.ContactMaterial(groundMaterial, enemyMaterial, { friction: 0.3, restitution: 0.1 }); const enemyPlayer = new CANNON.ContactMaterial(playerMaterial, enemyMaterial, { friction: 0, restitution: 0.5 }); const ballEnemy = new CANNON.ContactMaterial(ballPhysicsMaterial, enemyMaterial, { friction: 0.1, restitution: 0.1 }); world.addContactMaterial(playerGround); world.addContactMaterial(ballGround); world.addContactMaterial(ballPlayer); world.addContactMaterial(ballBall); world.addContactMaterial(enemyGround); world.addContactMaterial(enemyPlayer); world.addContactMaterial(ballEnemy); const groundShape = new CANNON.Plane(); groundBody = new CANNON.Body({ mass: 0, material: groundMaterial }); groundBody.addShape(groundShape); groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); world.addBody(groundBody); console.log("Cannon.js initialized."); }

        // --- Pointer Lock Controls Setup --- (unchanged)
        function initPointerLock() { console.log("Initializing PointerLockControls..."); controls = new PointerLockControls(camera, document.body); const blocker = document.getElementById('blocker'); const instructions = document.getElementById('instructions'); if (!blocker || !instructions) { console.error("UI elements not found!"); displayError("UI要素が見つかりません"); return; } instructions.addEventListener('click', () => { console.log("Instructions clicked..."); controls.lock(); }); controls.addEventListener('lock', () => { console.log("Pointer locked."); instructions.style.display = 'none'; blocker.style.display = 'none'; }); controls.addEventListener('unlock', () => { console.log("Pointer unlocked."); blocker.style.display = 'flex'; instructions.style.display = ''; moveForward = moveBackward = moveLeft = moveRight = false; if (playerBody) { playerBody.velocity.set(0, 0, 0); playerBody.angularVelocity.set(0, 0, 0); console.log("Player velocity reset on unlock."); } }); scene.add(controls.getObject()); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); document.addEventListener('pointerdown', onPointerDown); console.log("PointerLockControls initialized."); }

        // --- Create Scenery Elements --- (unchanged)
        function createEnvironment() { console.log("Creating environment..."); const groundGeometry = new THREE.PlaneGeometry(300, 300, 50, 50); const groundMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x77aa77, roughness: 0.9, metalness: 0.1 }); const groundMesh = new THREE.Mesh(groundGeometry, groundMeshMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.receiveShadow = true; scene.add(groundMesh); const roadGeometry = new THREE.PlaneGeometry(8, 250); const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 1.0 }); const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial); roadMesh.rotation.x = -Math.PI / 2; roadMesh.position.y = 0.01; roadMesh.receiveShadow = true; scene.add(roadMesh); createMountain(-80, -60, 40, 60); createMountain(90, 40, 35, 50); createMountain(20, 100, 30, 45); const treePositions = [{ x: 15, z: -15 }, { x: -10, z: -25 }, { x: 20, z: 30 }, { x: -25, z: 10 }, { x: 5, z: 50 }, { x: -35, z: -40 }, { x: 40, z: -5 }, { x: 55, z: 60 }]; treePositions.forEach(pos => createVoxelTree(pos.x, pos.z)); createVoxelCloud(-50, 70, -80); createVoxelCloud(0, 80, -120); createVoxelCloud(60, 90, -100); createVoxelCloud(30, 65, 80); createVoxelCloud(-70, 75, 50); console.log("Creating boxes..."); createBox(5, 1.5, -5, 3, 3, 3); createBox(-8, 1, 10, 2, 2, 2); createBox(10, 2.5, 15, 5, 5, 2); createBox(-15, 3.5, -8, 4, 7, 4); console.log("Creating enemies..."); createEnemy(-20, 1, 20); createEnemy(30, 1, -30); createEnemy(0, 1, -40); console.log("Enemies created."); console.log("Environment created."); }
        function createBox(x, y, z, width, height, depth) { const boxGeometry = new THREE.BoxGeometry(width, height, depth); const boxMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.7, metalness: 0.2 }); const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial); boxMesh.position.set(x, y, z); boxMesh.castShadow = true; boxMesh.receiveShadow = true; scene.add(boxMesh); const halfExtents = new CANNON.Vec3(width / 2, height / 2, depth / 2); const boxShape = new CANNON.Box(halfExtents); const boxBody = new CANNON.Body({ mass: 0, material: groundMaterial }); boxBody.addShape(boxShape); boxBody.position.set(x, y, z); world.addBody(boxBody); meshes.push(boxMesh); bodies.push(boxBody); }
        function createMountain(x, z, radius, height) { const G = new THREE.ConeGeometry(radius, height, 16); const M = new THREE.MeshStandardMaterial({ color: new THREE.Color(0x665544).multiplyScalar(Math.random() * 0.1 + 0.9), roughness: 1.0 }); const m = new THREE.Mesh(G, M); m.position.set(x, height / 2 - 0.1, z); m.castShadow = true; m.receiveShadow = true; scene.add(m); const S = new CANNON.Cylinder(radius * 0.8, radius, height, 16); const B = new CANNON.Body({ mass: 0, material: groundMaterial }); B.position.set(x, height / 2, z); B.addShape(S); world.addBody(B); meshes.push(m); bodies.push(B); }
        function createVoxelTree(x, z) { const tH = THREE.MathUtils.randInt(4, 7); const lS = THREE.MathUtils.randInt(3, 5); const lBY = tH; const tG = new THREE.BoxGeometry(1, tH, 1); const tM = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); const tMe = new THREE.Mesh(tG, tM); tMe.position.set(x, tH / 2, z); tMe.castShadow = true; scene.add(tMe); const lG = new THREE.BoxGeometry(1, 1, 1); const lM = new THREE.MeshStandardMaterial({ color: 0x228B22 }); const lGr = new THREE.Group(); for (let ly = 0; ly < lS; ly++) { for (let lx = -Math.floor(lS / 2); lx <= Math.floor(lS / 2); lx++) { for (let lz = -Math.floor(lS / 2); lz <= Math.floor(lS / 2); lz++) { if (Math.random() < 0.2 && lS > 3) continue; if (Math.abs(lx) === Math.floor(lS / 2) && Math.abs(lz) === Math.floor(lS / 2) && ly > lS * 0.6) continue; const lMe_ = new THREE.Mesh(lG, lM); lMe_.position.set(lx, lBY + ly - lS * 0.3, lz); lMe_.castShadow = true; lGr.add(lMe_); } } } lGr.position.set(x, 0, z); scene.add(lGr); const tH_ = tH + lS * 0.7; const tW = lS; const tD = lS; const tS = new CANNON.Box(new CANNON.Vec3(tW / 2, tH_ / 2, tD / 2)); const tB = new CANNON.Body({ mass: 0, material: groundMaterial }); tB.position.set(x, tH_ / 2, z); tB.addShape(tS); world.addBody(tB); meshes.push(tMe, lGr); bodies.push(tB); }
        function createVoxelCloud(x, y, z) { const cG = new THREE.Group(); const cM = new THREE.MeshBasicMaterial({ color: 0xffffff }); const cbG = new THREE.BoxGeometry(1, 1, 1); const nB = THREE.MathUtils.randInt(8, 20); const cR = 4; for (let i = 0; i < nB; i++) { const bM = new THREE.Mesh(cbG, cM); bM.position.set( (Math.random() - 0.5) * cR * 2, (Math.random() - 0.5) * cR * 0.8, (Math.random() - 0.5) * cR * 1.5 ); bM.rotation.set(Math.random() * 0.1, Math.random() * 0.1, Math.random() * 0.1); cG.add(bM); } cG.position.set(x, y, z); scene.add(cG); }
        function createEnemy(x, y, z) { const eS = 1.5; const eG = new THREE.BoxGeometry(eS, eS, eS); const eMM = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.8 }); const eM = new THREE.Mesh(eG, eMM); eM.position.set(x, y, z); eM.castShadow = true; scene.add(eM); const eSh = new CANNON.Box(new CANNON.Vec3(eS / 2, eS / 2, eS / 2)); const eB = new CANNON.Body({ mass: 20, material: enemyMaterial, linearDamping: 0.8, collisionFilterGroup: enemyCollisionGroup, collisionFilterMask: playerCollisionGroup | enemyCollisionGroup | ballCollisionGroup | 1 }); eB.addShape(eSh); eB.position.set(x, y, z); eB.isEnemy = true; world.addBody(eB); const en = { mesh: eM, body: eB, health: 1 }; enemies.push(en); console.log(`Enemy created at ${x}, ${y}, ${z}`); }

        // --- Create Player (Physics Body) --- (unchanged)
        function createPlayer() { console.log("Creating player..."); const playerShape = new CANNON.Sphere(playerRadius); if (!playerMaterial) { console.error("Player material error!"); return; } playerBody = new CANNON.Body({ mass: playerMass, position: new CANNON.Vec3(0, 2, 5), shape: playerShape, material: playerMaterial, linearDamping: 0.7, angularDamping: 1.0, fixedRotation: true, collisionFilterGroup: playerCollisionGroup, collisionFilterMask: 1 | enemyCollisionGroup | ballCollisionGroup }); world.addBody(playerBody); console.log("Player created."); }

        // --- Create Lights --- (unchanged)
        function createLights() { console.log("Creating lights..."); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(30, 100, 40); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; const shadowCamSize = 100; directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize; directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 300; scene.add(directionalLight); console.log("Lights created."); }

        // --- Shoot Ball Function --- (unchanged)
        function shootBall() { if (!controls.isLocked) return; console.log("--- Shooting ball ---"); const ballMesh = new THREE.Mesh(ballGeometry, ballMeshMaterial); ballMesh.castShadow = true; ballMesh.receiveShadow = true; if (!ballPhysicsMaterial) { console.warn("Ball physics material error!"); return; } const ballBody = new CANNON.Body({ mass: 0.5, shape: ballShape, material: ballPhysicsMaterial, linearDamping: 0.1, angularDamping: 0.1, collisionFilterGroup: ballCollisionGroup, collisionFilterMask: 1 | playerCollisionGroup | enemyCollisionGroup | ballCollisionGroup }); ballBody.addEventListener('collide', (event) => { const contact = event.contact; const otherBody = contact.bi.id === ballBody.id ? contact.bj : contact.bi; if (otherBody.isEnemy) { console.log("Ball hit enemy!"); const enemyIndex = enemies.findIndex(e => e.body.id === otherBody.id); if (enemyIndex !== -1) { const enemyToRemove = enemies[enemyIndex]; console.log("Removing enemy:", enemyToRemove.body.id); world.removeBody(enemyToRemove.body); scene.remove(enemyToRemove.mesh); enemies.splice(enemyIndex, 1); const ballIndex = balls.findIndex(b => b.body === ballBody); if (ballIndex !== -1) { world.removeBody(ballBody); scene.remove(ballMesh); balls.splice(ballIndex, 1); } } else { console.warn("Collided enemy not found?"); } } }); const shootDirectionTHREE = new THREE.Vector3(); camera.getWorldDirection(shootDirectionTHREE); const camPosTHREE = new THREE.Vector3(); camera.getWorldPosition(camPosTHREE); const shootDirectionCANNON = new CANNON.Vec3(shootDirectionTHREE.x, shootDirectionTHREE.y, shootDirectionTHREE.z); const camPosCANNON = new CANNON.Vec3(camPosTHREE.x, camPosTHREE.y, camPosTHREE.z); const startOffsetDistance = 1.0; const startOffsetCANNON = new CANNON.Vec3(); shootDirectionCANNON.scale(startOffsetDistance, startOffsetCANNON); camPosCANNON.vadd(startOffsetCANNON, ballBody.position); ballMesh.position.set(ballBody.position.x, ballBody.position.y, ballBody.position.z); const shootVelocity = 35; const upwardBias = 0.15; shootDirectionCANNON.y += upwardBias; shootDirectionCANNON.normalize(); shootDirectionCANNON.scale(shootVelocity, ballBody.velocity); console.log("Ball Velocity:", ballBody.velocity.x.toFixed(2), ballBody.velocity.y.toFixed(2), ballBody.velocity.z.toFixed(2)); console.log("----------------------"); scene.add(ballMesh); world.addBody(ballBody); balls.push({ mesh: ballMesh, body: ballBody }); setTimeout(() => { const index = balls.findIndex(b => b.body === ballBody); if (index !== -1) { world.removeBody(ballBody); scene.remove(ballMesh); balls.splice(index, 1); } }, 8000); }


        // --- Animation Loop --- ★ 修正: controls チェック追加
        let lastCallTime = performance.now();
        const raycastOptions = { collisionFilterGroup: 1, collisionFilterMask: 1, skipBackfaces: true };
        const groundCheckResult = new CANNON.RaycastResult();
        const enemyTargetDirection = new CANNON.Vec3();

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now(); const deltaTime = (currentTime - lastCallTime) / 1000.0; lastCallTime = currentTime;

            // ★ controls の存在チェックを追加
            if (controls && controls.isLocked && playerBody) {
                world.step(timeStep, deltaTime);

                // Ground Check
                const rayFrom = playerBody.position; const rayTo = new CANNON.Vec3(rayFrom.x, rayFrom.y - playerRadius - 0.1, rayFrom.z);
                groundCheckResult.reset(); world.raycastClosest(rayFrom, rayTo, raycastOptions, groundCheckResult);
                if (groundCheckResult.hasHit && groundCheckResult.body.material === groundMaterial) { if (!canJump) { /* console.log("Grounded"); */ } canJump = true; }
                else { if (canJump) { /* console.log("In Air"); */ } canJump = false; }

                // Player Velocity Log (Keep for debugging if needed)
                // if(performance.now() % 100 < 10) { console.log(`Player Velocity: ...`); }


                // Player Movement
                const inputVelocity = new THREE.Vector3(); const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);
                if (moveForward) inputVelocity.z = -1; if (moveBackward) inputVelocity.z = 1;
                if (moveLeft) inputVelocity.x = -1; if (moveRight) inputVelocity.x = 1;

                if (inputVelocity.lengthSq() > 0) { // If there is input
                    inputVelocity.normalize(); inputVelocity.applyEuler(euler);
                    playerBody.velocity.x = inputVelocity.x * moveSpeed;
                    playerBody.velocity.z = inputVelocity.z * moveSpeed;
                } else { // If there is NO input, apply explicit damping
                    const dampFactor = 0.8;
                    playerBody.velocity.x *= dampFactor;
                    playerBody.velocity.z *= dampFactor;
                    // REMOVED: The check to set velocity to exactly zero
                }
                // Y velocity is handled by physics engine (gravity, jump)

                // Enemy AI
                enemies.forEach(enemy => { if (enemy.body && playerBody) { playerBody.position.vsub(enemy.body.position, enemyTargetDirection); enemyTargetDirection.y = 0; if (enemyTargetDirection.lengthSquared() > 0.1) { enemyTargetDirection.normalize(); enemy.body.velocity.x = enemyTargetDirection.x * enemySpeed; enemy.body.velocity.z = enemyTargetDirection.z * enemySpeed; } } });

                // Sync camera position
                camera.position.copy(playerBody.position); camera.position.y += playerHeight * 0.8;

            } else if (!playerBody) { // playerBody がない場合の警告
                 console.warn("Player body not initialized.");
            } else if (!controls) { // controls がない場合の警告
                 console.warn("Controls not initialized yet in animate loop.");
                 // エラーを防ぐため、ここで処理を中断しても良い
                 // return;
            }
             // controls があってもロックされていない場合は、ここでは何もしない

            // Sync Meshes
            balls.forEach(ball => { if (ball.mesh && ball.body) { ball.mesh.position.set(ball.body.position.x, ball.body.position.y, ball.body.position.z); ball.mesh.quaternion.set(ball.body.quaternion.x, ball.body.quaternion.y, ball.body.quaternion.z, ball.body.quaternion.w); } });
            enemies.forEach(enemy => { if (enemy.mesh && enemy.body) { enemy.mesh.position.set(enemy.body.position.x, enemy.body.position.y, enemy.body.position.z); enemy.mesh.quaternion.set(enemy.body.quaternion.x, enemy.body.quaternion.y, enemy.body.quaternion.z, enemy.body.quaternion.w); } });

            renderer.render(scene, camera);
        }


        // --- Event Handlers --- (unchanged)
        function onWindowResize() { if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } }
        function onKeyDown(event) { if (!controls.isLocked || !playerBody) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = true; break; case 'KeyA': case 'ArrowLeft': moveLeft = true; break; case 'KeyS': case 'ArrowDown': moveBackward = true; break; case 'KeyD': case 'ArrowRight': moveRight = true; break; case 'Space': if (canJump) { console.log("Jump Key!"); playerBody.velocity.y = jumpVelocity; canJump = false; } break; } }
        function onKeyUp(event) { switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = false; break; case 'KeyA': case 'ArrowLeft': moveLeft = false; break; case 'KeyS': case 'ArrowDown': moveBackward = false; break; case 'KeyD': case 'ArrowRight': moveRight = false; break; } }
        function onPointerDown(event) { if (controls.isLocked && event.button === 0) { shootBall(); } }
        function displayError(message) { const blocker = document.getElementById('blocker'); const instructions = document.getElementById('instructions'); if (blocker && instructions) { instructions.innerHTML = `<p style="color: red; font-weight: bold;">エラー</p><p>${message}</p>`; blocker.style.display = 'flex'; instructions.style.display = ''; if (controls) { instructions.removeEventListener('click', controls.lock); } } else { alert("エラー: " + message); } }
        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
    </script>
</body>
</html>